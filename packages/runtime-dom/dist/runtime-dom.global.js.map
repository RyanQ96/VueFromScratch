{
  "version": 3,
  "sources": ["../src/index.ts", "../src/nodeOps.ts", "../src/modules/patchClass.ts", "../src/modules/patchEvent.ts", "../src/modules/patchStyle.ts", "../src/modules/patchAttr.ts", "../src/patchProp.ts", "../../shared/src/index.ts", "../../runtime-core/src/createVNode.ts", "../../runtime-core/src/h.ts", "../../runtime-core/src/createRenderer.ts", "../../reactivity/src/effect.ts", "../../reactivity/src/baseHandler.ts", "../../reactivity/src/reactive.ts", "../../reactivity/src/computed.ts", "../../reactivity/src/watch.ts", "../../reactivity/src/ref.ts"],
  "sourcesContent": ["import { nodeOps } from './nodeOps'\nimport { patchProp } from \"./patchProp\";\nimport { createRenderer } from '@vue/runtime-core'\n\nexport * from '@vue/runtime-core'\n\nexport const renderOptions = {\n    ...nodeOps,\n    patchProp\n};\n\nexport function render(vnode, container) {\n    let { render } = createRenderer(renderOptions)\n    render(vnode, container)\n}\n", "export const nodeOps = {\n    createElement(tagName) {\n        return document.createElement(tagName);\n    }, \n    createTextNode(text) {\n        return document.createTextNode(text); \n    }, \n    insert(child, container, anchor = null) {\n        return container.insertBefore(child, anchor); // if anchor = null, insertBefore behaves like appendChild\n    }, \n    remove(child) {\n        const parent = child.parentNode; \n        if (parent) {\n            parent.removeChild(child); \n        }\n    }, \n    querySelector(selector) {\n        return document.querySelector(selector); \n    },  \n    parentNode(child) {\n        return child.parentNode; \n    }, \n    nextSibling(child) {\n        return child.nextSibling; \n    }, \n    setText(node, text) { // \u7ED9\u6587\u672C\u8282\u70B9\u8BBE\u7F6E\u5185\u5BB9\n        node.nodeValue = text;\n    }, \n    setElementText(element, text) { // \u7ED9\u5143\u7D20\u8282\u70B9\u8BBE\u7F6E\u5185\u5BB9\n        element.textContent = text;\n    }\n}\n\n\n// createElementNode \n// createTestElement \n// insert, delete, modify, replace ElementNode \n// search parent, children \n// We will use these ops to render element in a webpage", "export function patchClass(el, nextValue) {\n    if (nextValue == null) {\n        el.removeAttribute('class');\n    } else {\n        el.className = nextValue\n    }\n}", "// click fn1 => fn2 \n// Way 1. unbound fn1 and bound fn2? -> low efficiency\n// Way 2. bound a function that can call fn1() or fn2() \nexport function patchEvent(el, eventName, nextValue) {\n    // vue bind ._vei to el to indicate that el has event listener\n    const invokers = el._vei || (el._vei = {})\n    const eName = eventName.slice(2).toLowerCase()\n    const existingInvoker = invokers[eventName]\n    if (existingInvoker && nextValue) {\n        existingInvoker.value = nextValue\n    } else {\n        if (nextValue) {\n            // for the first time\n            const invoker = createInvoker(nextValue)\n            invokers[eventName] = invoker\n            el.addEventListener(eName, invoker)\n        } else if (existingInvoker) {\n            // \u6CA1\u6709nextValue\uFF0C\u8BF4\u660E\u8981\u79FB\u9664\u4E8B\u4EF6\n            el.removeEventListener(eName, existingInvoker)\n            invokers[eventName] = null\n        }\n    }\n}\n\n\nfunction createInvoker(preValue) {\n    const invoker = (e) => {\n        invoker.value(e)\n    }\n    invoker.value = preValue // later on, we just need to change value's reference\n    return invoker\n}\n\n", "export function patchStyle(el, preValue, nextValue) {\n    const style = el.style;\n    for (let key in nextValue) {\n        style[key] = nextValue[key]\n    }\n\n    if (preValue) {\n        for (let key in preValue) {\n            if (nextValue[key] == null) {\n                style[key] = null\n            }\n        }\n    }\n}", "export function patchAttr(el, key, nextValue) {\n    if (nextValue == null) {\n        el.removeAttribute(key)\n    } else {\n        el.setAttribute(key, nextValue)\n    }\n}", "import { patchClass } from \"./modules/patchClass\";\nimport { patchEvent } from \"./modules/patchEvent\";\nimport { patchStyle } from \"./modules/patchStyle\";\nimport { patchAttr } from \"./modules/patchAttr\";\n\n\nexport const patchProp = (el, key, preValue, nextValue) => { // need to compare preValue and nextValue\n    if (key === 'class') {\n        patchClass(el, nextValue)\n    }\n    else if (key === 'style') {\n        patchStyle(el, preValue, nextValue)\n    }\n    else if (/on[^a-z]/.test(key)){\n        patchEvent(el, key, nextValue) \n    } \n    else {\n        patchAttr(el, key, nextValue)\n    }\n}", "export const isObject = (value) => {\n  return typeof value === 'object' && value !== null\n}\n\nexport const isFunction = (value) => {\n  return typeof value === 'function' && value != null \n}\n\nexport const isArray = (value) => {\n  return value != null && Array.isArray(value) \n}\n\nexport const isString = (value) => {\n  return typeof value === 'string'\n}\n\nexport const isNumber = (value) => {\n  return typeof value === 'number'\n}\n", "import { isArray, isString } from \"@vue/shared\"\n\nexport function isVNode(vnode) {\n    return !!vnode.__v_isVNode\n}\n\nexport const Text = Symbol('Text') \n\nexport function createVNode(type, props = null, children = null) {\n\n    // \u540E\u7EED\u5224\u65AD\u6709\u4E0D\u7528\u7C7B\u578B\u7684\u865A\u62DF\u8282\u70B9\n    let shapeFlag = isString(type) ? ShapeFlags.ELEMENT : 0 \n\n    // \u5C06\u5F53\u524D\u7684\u865A\u62DF\u8282\u70B9 \u548C \u81EA\u5DF1\u513F\u5B50\u7684\u865A\u62DF\u8282\u70B9\u6620\u5C04\u8D77\u6765\n    const vNode = { // vNode\u8981\u5BF9\u5E94\u771F\u5B9E\u8282\u70B9\n        __v_isVNode: true, // indicate its a vNode\n        type, \n        props, \n        children, \n        key: props && props.key, // indicate its uniqueness\n        el: null, // indicate its corresponding real node\n        shapeFlag, \n    }    \n\n    if (children) {\n        let temp = 0; \n        if (isArray(children)) { // \u8D70\u5230createVNode\u5B83\u8981\u4E48\u662F\u6570\u7EC4, \u8981\u4E48\u662F\u5B57\u7B26\u4E32\n            temp = ShapeFlags.ARRAY_CHILDREN \n        } else {\n            children = String(children)\n            temp = ShapeFlags.TEXT_CHILDREN\n        }\n        vNode.shapeFlag |= temp \n    }\n\n\n    // shapeFlag \u6211\u60F3\u8981\u77E5\u9053\u8FD9\u4E2A\u865A\u62DF\u8282\u70B9\u7684\u513F\u5B50\u662F\u6570\u7EC4, \u5143\u7D20, \u8FD8\u662F\u6587\u672C\n    return vNode\n}\n\n\nexport const enum ShapeFlags {\n    ELEMENT = 1, // 1 << 0 \n    FUNCTIONAL_COMPONENT = 1 << 1, // 1 << 1 \n    STATEFUL_COMPONENT = 1 << 2, // 1 << 2 \n    TEXT_CHILDREN = 1 << 3, // 1 << 3 \n    ARRAY_CHILDREN = 1 << 4, // 1 << 4 \n    SLOTS_CHILDREN = 1 << 5, // 1 << 5 \n    TELEPORT = 1 << 6, \n    SUSPENSE = 1 << 7, \n    COMPONENT_SHOULD_KEEP_ALIVE = 1 << 8, \n    COMPONENT_KEPT_ALIVE = 1 << 9, \n    COMPONENT = ShapeFlags.STATEFUL_COMPONENT | ShapeFlags.FUNCTIONAL_COMPONENT,\n}\n// \u6743\u9650\u7EC4\u5408", "import { isArray, isObject } from \"@vue/shared\";\nimport { createVNode, isVNode } from \"./createVNode\";\n// h function will call createVNode\n// 1) element, content\n// 2) element, props, content\n// 3) element, props, children\n// 4) element, children\n\n\n// createVNode \u540E\u7EED\u8FD8\u6709\u4F18\u5316, \u53EF\u4EE5\u6807\u8BB0\u5904\u54EA\u4E9B\u8282\u70B9\u662F\u9759\u6001\u7684\nexport function h(type, propsOrChildren, children) {\n    // check the length of arguments to match mode \n    const l = arguments.length;\n    if (l === 2) {\n        if (isObject(propsOrChildren) && !isArray(propsOrChildren)) { // \u5BF9\u8C61, \u6570\u7EC4(\u80AF\u5B9A\u662Fchildren), props\n            // \u5143\u7D20\u5BF9\u8C61 or props\n            if (isVNode(propsOrChildren)) {\n                return createVNode(type, null, [propsOrChildren])\n            } else {\n                return createVNode(type, propsOrChildren, null)\n            }\n        } else {\n            // propsOrChilden would be eight children or text child\n            return createVNode(type, null, propsOrChildren)\n        }\n    } else if (l === 3) {\n        if (isVNode(children)) {\n            return createVNode(type, propsOrChildren, [children])\n        } else {\n            return createVNode(type, propsOrChildren, children)\n        } \n    } else {\n        children = Array.from(arguments).slice(2)\n        return createVNode(type, propsOrChildren, children)\n    }\n}", "import { isString, isNumber } from \"@vue/shared\";\nimport { ShapeFlags, Text, createVNode } from \"./createVNode\";\n\nexport function createRenderer(options) {\n    // options is the user's custom renderer options\n\n    // User can call this function and pass in render options \n    console.log(options)\n\n    let {\n        createElement: hostCreateElement,\n        createTextNode: hostCreateTextNode,\n        insert: hostInsert,\n        remove: hostRemove,\n        querySelector: hostQuerySelector,\n        parentNode: hostParentNode,\n        nextSibling: hostNextSibling,\n        setText: hostSetText,\n        setElementText: hostSetElementText,\n        patchProp: hostPatchProp\n    } = options // destructure the options and rename to indicate that \n    // these are the host's apis, not only for DOM but also for other platforms\n\n\n    function normalize(children, i) {\n        if (isString(children[i]) || isNumber(children[i])) {\n            children[i] = createVNode(Text, null, children[i])\n        }\n        return children[i]\n    }\n\n    function mountChildren(el, children) {\n        // children could be text, or an array of vnodes\n        for (let i = 0; i < children.length; i++) {\n            let child = normalize(children, i)\n            patch(null, child, el)\n        }\n    }\n\n    function mountElement(vnode, container) {\n        let {\n            type,\n            props,\n            children,\n            shapeFlag\n        } = vnode; // destructure the vnode to get the type, props, children, and shapeFlag\n        // \u540E\u7EED\u9700\u8981\u5BF9\u6BD4\u865A\u62DF\u8282\u70B9\u7684\u5DEE\u5F02\u66F4\u65B0\u771F\u5B9E\u8282\u70B9, \u6240\u4EE5\u9700\u8981\u4FDD\u7559\u5BF9\u5E94\u7684\u771F\u5B9E\u8282\u70B9\n        let el = vnode.el = hostCreateElement(type) // create the element node and save it to the vnodekl\n        if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {\n            hostSetElementText(el, children)\n        } else if (shapeFlag * ShapeFlags.ARRAY_CHILDREN) {\n            mountChildren(el, children)\n        }\n\n        hostInsert(el, container)\n    }\n\n    function processText(prevVNode, nextVNode, container) {\n        if (prevVNode == null) {\n            let el = nextVNode.el = hostCreateTextNode(nextVNode.children) \n            hostInsert(el, container)\n        } else {\n            // update text node\n        }\n    }\n\n    function processElement(prevVNode, nextVNode, container) {\n        // debugger\n        if (prevVNode == null) {\n            mountElement(nextVNode, container)\n        } else {\n            // diff algorithm\n        }\n    }\n\n    function patch(prevVNode, nextVNode, container) { // patch function is used to update the container's content\n        const { type, shapeFlag } = nextVNode;\n        switch (type) {\n            case Text:\n                processText(prevVNode, nextVNode, container)\n                break;\n\n            default:\n                if (shapeFlag & ShapeFlags.ELEMENT) { \n                    processElement(prevVNode, nextVNode, container)\n                }\n        }\n\n        // if (prevNode == null) {// No existing node \n        //     // mount element \n        //     mountElement(nextVNode, container)\n        // } else {\n        //     // diff algorithm \n        // }\n    }\n\n\n    function render(vnode, container) {\n        // we need to render vnode into the container by calling the api in options\n        if (vnode == null) {\n            // \u5378\u8F7D\u5143\u7D20 if vnode is null, we will remove the container's content\n\n        } else {\n            // \u66F4\u65B0 or \u521D\u59CB\u5316\n            patch(container._vnode || null, vnode, container)\n\n        }\n        // \u7B2C\u4E00\u6B21\u6E32\u67D3\u5C31\u5C06vnode\u4FDD\u5B58\u5230\u4E86container\u4E0A\u9762\n        container._vnode = vnode; // store the vnode in container so that we can use it to update the container's content\n\n        console.log(vnode, container)\n    }\n    return {\n        render\n    }\n} \n", "export let activeEffect = undefined\nexport class ReactiveEffect {\n  public active = true\n  public fn\n  public parent = null\n  public deps = new Set()\n  constructor(fn, public scheduler?) { //\u4F20\u9012\u7684fn\u4F1A\u88AB\u653E\u5728fn\u4E0A\n    this.fn = fn\n  }\n  run() {\n    if (!this.active) {\n      return this.fn()\n    } else {\n      // dependencies tracking \n      try {\n        cleanEffect(this)\n        this.parent = activeEffect\n        activeEffect = this\n        return this.fn()\n      } finally {\n        activeEffect = this.parent\n        this.parent = null\n      }\n    }\n  }\n  stop() {\n    if (this.active) {\n      this.active = false\n      cleanEffect(this)\n    }\n  }\n}\n\n\nexport function cleanEffect(effect){ \n  console.log('effect cleaned')\n  effect.deps.forEach(deps => {\n    deps.delete(effect)\n  })\n  effect.deps.clear()\n}\n\nexport function effect(fn, options = {} as any) {\n  const _effect = new ReactiveEffect(fn, options.scheduler)\n  _effect.run()\n  const runner = _effect.run.bind(_effect)\n  runner.effect = _effect //expose effect instance \n  return runner // User can mannually stop collect and runner \n}\n\nconst targetMap = new WeakMap()\n// map {object: {key: [effect, effect2....]}}\nexport function track(target, key) {\n  if (activeEffect) {\n    let depsMap = targetMap.get(target)\n    if (!depsMap) {\n      targetMap.set(target, (depsMap = new Map()))\n    }\n    let deps = depsMap.get(key)\n    if (!deps) {\n      depsMap.set(key, (deps = new Set()))\n    }\n    trackEffect(deps)\n  }\n}\n\nexport function trackEffect(deps) {\n  const shouldTrack = !deps.has(activeEffect)\n    if (shouldTrack) {\n      deps.add(activeEffect)\n      if (!activeEffect.deps.has(deps)) {\n        activeEffect.deps.add(deps)\n      }\n    }\n}\n\nexport function trigger(target, key, value) {\n  let depsMap = targetMap.get(target)\n  if (!depsMap) return  // key doesn't reply on any effect \n  const effects = depsMap.get(key)\n  triggerEffects(effects)\n}\n\nexport function triggerEffects(effects) {\n  effects && Array.from(effects).forEach((effect: ReactiveEffect) => {\n    if (effect !== activeEffect) {\n      if (effect.scheduler) {\n        effect.scheduler()\n      } else {\n        effect.run()\n      }\n    } // re-execute effect\n  })\n}", "import { track, trigger } from \"./effect\";\nimport { reactive } from \"./reactive\"\nimport { isObject } from \"@vue/shared\";\nexport const enum  ReactiveFlags {\n  IS_REACTIVE = '__v_isReactive'\n}\nexport const baseHandler = {\n  get(target, key, receiver) {\n    if (key === ReactiveFlags.IS_REACTIVE) {\n      return true\n    } else {\n      // relate key and effect\n      track(target, key)\n      // console.log(`logging: collect dependency for key: ${String(key)}`)\n      // lazy proxy \n      let res = Reflect.get(target, key, receiver)\n      if (isObject(res)) {\n        return reactive(res)\n      } else {\n        return res\n      }\n    }\n  },\n  set(target, key, value, receiver) {\n    // based on key, find which effects need to change \n    let oldValue = target[key] \n    if (oldValue != value) {\n      let result = Reflect.set(target, key, value, receiver)\n      trigger(target, key, value) \n      return result; \n    }\n  }\n} \n", "import { isObject } from \"@vue/shared\";\nimport { activeEffect } from \"./effect\";\nimport { baseHandler, ReactiveFlags } from \"./baseHandler\";\nconst reactiveMap = new WeakMap(); // key of weakmap has to be an object\n// v8's gabage collection mechanism \n\nexport function reactive(target) {\n  if (!isObject(target)) {\n    return target\n  }\n\n  if (target[ReactiveFlags.IS_REACTIVE]) {\n    return target\n  }\n\n  const existing = reactiveMap.get(target)\n  if (existing) {\n    return existing\n  }\n\n  const proxy = new Proxy(target, baseHandler)\n\n  reactiveMap.set(target, proxy)\n  return proxy\n}\n\nexport function isReactive(object) {\n  return !!(object && object[ReactiveFlags.IS_REACTIVE])\n}", "import { isObject, isFunction } from \"@vue/shared\";\nimport { ReactiveEffect, trackEffect, triggerEffects } from \"./effect\";\n\n\nclass ComputedRefImpl { // computed basically is an effect\n  private _value\n  private _dirty = true\n  private _effect\n  public deps = new Set()\n  constructor(public getter, public setter) {\n    this._effect = new ReactiveEffect(getter, ()=>{\n      if (!this._dirty) {\n        this._dirty = true\n        // notify collected effects to re-run\n        triggerEffects(this.deps)\n      }\n    })\n  }\n  get value() {\n    trackEffect(this.deps)\n    if (this._dirty) {\n      this._value = this._effect.run() \n      this._dirty = false\n    }\n    return this._value\n  }\n  set value(newValue) {\n    this.setter(newValue) \n  }\n}\n\nexport function computed(getterOrOptions) {\n  let getter\n  let setter\n  let isGetter = isFunction(getterOrOptions) \n  const fn = () => console.warn('computed is read only')\n  if (isGetter) {\n    getter = getterOrOptions\n    setter = () => fn \n  } else {\n    getter = getterOrOptions.getter \n    setter = getterOrOptions.setter || fn\n  }\n  return new ComputedRefImpl(getter, setter)\n}", "import { isObject, isFunction } from \"@vue/shared\";\nimport { isReactive } from \"./reactive\";\nimport { ReactiveEffect } from \"./effect\";\nfunction traverse(value, set = new Set()) {\n  if (!isObject) return value\n  if (set.has(value)) return\n  set.add(value)\n  for (let key in value) {\n    traverse(value[key], set)\n  }\n  return value\n}\n\nexport function watch(source, cb) {\n  let getter;\n  if (isReactive(source)) {\n    getter = () => traverse(source)\n  } else if (isFunction(source)) {\n    getter = source\n  } else {\n    console.warn(\"source is not an reactive object or a function\")\n    return\n  }\n  let oldValue\n  let waiting = false\n  const job = () => {\n    if (!waiting) {\n      waiting = true\n      Promise.resolve().then(() => {\n        const newValue = effect.run()\n        cb(newValue, oldValue)\n        oldValue = newValue\n        waiting = false\n      })\n    }\n  }\n  const effect = new ReactiveEffect(getter, job);\n  oldValue = effect.run()\n}", "import { isArray, isObject } from \"@vue/shared\";\nimport { reactive } from \"./reactive\"\nimport { trackEffect, triggerEffects } from \"./effect\";\n\nfunction toReactive(value) {\n  return isObject(value) ? reactive(value) : value\n}\n\nclass RefImpl {\n  public deps = new Set()\n  public _value\n  public rawValue\n  constructor(value) {\n    this._value = toReactive(value)\n    this.rawValue = value\n  }\n  get value() {\n    trackEffect(this.deps)\n    return this._value\n  }\n  set value(newVal) {\n    if(newVal !== this._value) {\n      this._value = toReactive(newVal)\n      this.rawValue = newVal\n      triggerEffects(this.deps)\n    }\n  }\n}\n\n\nclass ObjectRefImpl {\n  constructor(public object, public key) {}\n  get value() {\n    return this.object[this.key]\n  }\n  set value(newVal) {\n    this.object[this.key] = newVal\n  }\n}\n\nexport function ref(val) {\n  return new RefImpl(val)    \n}\n\nexport function toRef(target, key) {\n  return new ObjectRefImpl(target, key) \n}\n\nexport function toRefs(object) {\n  let result = isArray(object) ? new Array(object.length) : {}\n  for (let key in object) {\n    result[key] = toRef(object, key) \n  }\n  return result\n}"],
  "mappings": "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",
  "names": ["ShapeFlags", "render", "effect", "effect", "render"]
}
